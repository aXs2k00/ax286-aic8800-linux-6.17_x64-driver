--- FILE: rwnx_rx.c (Affected Lines) ---
1636-#endif
1637-{
1638-#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
1639-	struct reord_ctrl *preorder_ctrl = (struct reord_ctrl *)data;
1640-#else
1641:	struct reord_ctrl *preorder_ctrl = from_timer(preorder_ctrl, t, reord_timer);
1642-#endif
1643-
1644-	AICWFDBG(LOGTRACE, "%s Enter \r\n", __func__);
1645-
1646-
--
2041-        struct ieee80211_hdr *hdr;
2042-
2043-        hdr = (struct ieee80211_hdr *)(skb->data + msdu_offset);
2044-        rwnx_vif = rwnx_rx_get_vif(rwnx_hw, hw_rxhdr->flags_vif_idx);
2045-        if (rwnx_vif) {
2046:            cfg80211_rx_spurious_frame(rwnx_vif->ndev, hdr->addr2, GFP_ATOMIC);
2047-        }
2048-        goto end;
2049-    }
2050-
2051-    /* Check if we need to forward the buffer */
--
2132-                        goto end;
2133-                    }
2134-                }
2135-
2136-                if (hw_rxhdr->flags_is_4addr && !rwnx_vif->use_4addr) {
2137:                    cfg80211_rx_unexpected_4addr_frame(rwnx_vif->ndev,
2138-                                                       sta->mac_addr, GFP_ATOMIC);
2139-                }
2140-            }
2141-
2142-            skb->priority = 256 + tid;//hw_rxhdr->flags_user_prio;

--- FILE: rwnx_main.c (Affected Lines) ---
1052-        cfg80211_stop_iface(rwnx_hw->wiphy, &vif->wdev, GFP_KERNEL);
1053-        #else
1054-        cfg80211_disconnected(vif->ndev, 0, NULL, 0, 0, GFP_KERNEL);
1055-        #endif
1056-    } else {
1057:        mutex_lock(&vif->wdev.mtx);
1058:        __acquire(&vif->wdev.mtx);
1059-        spin_lock_bh(&rwnx_hw->cb_lock);
1060-        rwnx_chanctx_unlink(vif);
1061-        rwnx_chanctx_link(vif, csa->ch_idx, &csa->chandef);
1062-        if (rwnx_hw->cur_chanctx == csa->ch_idx) {
1063-            rwnx_radar_detection_enable_on_cur_channel(rwnx_hw);
1064-            rwnx_txq_vif_start(vif, RWNX_TXQ_STOP_CHAN, rwnx_hw);
1065-        } else
1066-            rwnx_txq_vif_stop(vif, RWNX_TXQ_STOP_CHAN, rwnx_hw);
1067-        spin_unlock_bh(&rwnx_hw->cb_lock);
1068-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 3, 0))
1069:                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0, 0);
1070-#elif (LINUX_VERSION_CODE >=KERNEL_VERSION(5, 19, 2))
1071:                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef, 0);
1072-#else
1073:                cfg80211_ch_switch_notify(vif->ndev, &csa->chandef);
1074-#endif
1075-
1076:        mutex_unlock(&vif->wdev.mtx);
1077:        __release(&vif->wdev.mtx);
1078-    }
1079-    rwnx_del_csa(vif);
1080-}
1081-#endif
1082-
--
2894-    u8_l p2p = 0;
2895-    #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
2896-    rwnx_vif = (struct rwnx_vif *)data;
2897-    rwnx_hw = rwnx_vif->rwnx_hw;
2898-    #else
2899:    rwnx_hw = from_timer(rwnx_hw, t, p2p_alive_timer);
2900-    rwnx_vif = rwnx_hw->p2p_dev_vif;
2901-    #endif
2902-
2903-	//printk("%s enter %d \r\n", __func__, atomic_read(&rwnx_hw->p2p_alive_timer_count));
2904-
--
6412-    }
6413-
6414-    return 0;
6415-}
6416-
6417:static struct cfg80211_ops rwnx_cfg80211_ops = {
6418-    .add_virtual_intf = rwnx_cfg80211_add_iface,
6419-    .del_virtual_intf = rwnx_cfg80211_del_iface,
6420-    .change_virtual_intf = rwnx_cfg80211_change_iface,
6421-    .start_p2p_device = rwnx_cfgp2p_start_p2p_device,
6422-    .stop_p2p_device = rwnx_cfgp2p_stop_p2p_device,
--
6516-    struct wiphy *wiphy = rwnx_hw->wiphy;
6517-
6518-    if (!rwnx_mod_params.mesh)
6519-        return;
6520-
6521:    rwnx_cfg80211_ops.get_station = rwnx_cfg80211_get_station;
6522:    rwnx_cfg80211_ops.dump_station = rwnx_cfg80211_dump_station;
6523:    rwnx_cfg80211_ops.add_mpath = rwnx_cfg80211_add_mpath;
6524:    rwnx_cfg80211_ops.del_mpath = rwnx_cfg80211_del_mpath;
6525:    rwnx_cfg80211_ops.change_mpath = rwnx_cfg80211_change_mpath;
6526:    rwnx_cfg80211_ops.get_mpath = rwnx_cfg80211_get_mpath;
6527:    rwnx_cfg80211_ops.dump_mpath = rwnx_cfg80211_dump_mpath;
6528-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
6529:    rwnx_cfg80211_ops.get_mpp = rwnx_cfg80211_get_mpp;
6530:    rwnx_cfg80211_ops.dump_mpp = rwnx_cfg80211_dump_mpp;
6531-#endif
6532:    rwnx_cfg80211_ops.get_mesh_config = rwnx_cfg80211_get_mesh_config;
6533:    rwnx_cfg80211_ops.update_mesh_config = rwnx_cfg80211_update_mesh_config;
6534:    rwnx_cfg80211_ops.join_mesh = rwnx_cfg80211_join_mesh;
6535:    rwnx_cfg80211_ops.leave_mesh = rwnx_cfg80211_leave_mesh;
6536-
6537-    wiphy->flags |= (WIPHY_FLAG_MESH_AUTH | WIPHY_FLAG_IBSS_RSN);
6538-    wiphy->features |= NL80211_FEATURE_USERSPACE_MPM;
6539-    wiphy->interface_modes |= BIT(NL80211_IFTYPE_MESH_POINT);
6540-
--
8719-    get_random_bytes(&dflt_mac[4], 2);
8720-#endif
8721-//#endif
8722-    /* create a new wiphy for use with cfg80211 */
8723-    AICWFDBG(LOGINFO, "%s sizeof(struct rwnx_hw):%d \r\n", __func__, (int)sizeof(struct rwnx_hw));
8724:    wiphy = wiphy_new(&rwnx_cfg80211_ops, sizeof(struct rwnx_hw));
8725-
8726-    if (!wiphy) {
8727-        dev_err(rwnx_platform_get_dev(rwnx_plat), "Failed to create new wiphy\n");
8728-        ret = -ENOMEM;
8729-        goto err_out;
